<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.NRefactory</name>
    </assembly>
    <members>
        <member name="T:ICSharpCode.NRefactory.Documentation.DocumentationComment">
            <summary>
            Represents a documentation comment.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Documentation.DocumentationComment.Xml">
            <summary>
            Gets the XML code for this documentation comment.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.DocumentationComment.#ctor(System.String,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a new DocumentationComment.
            </summary>
            <param name="xml">The XML text.</param>
            <param name="context">Context for resolving cref attributes.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.DocumentationComment.ResolveCref(System.String)">
            <summary>
            Resolves the given cref value to an entity.
            Returns null if the entity is not found, or if the cref attribute is syntactically invalid.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.GetPotentiallyNestedClassTypeReference">
            <summary>
            A type reference of the form 'Some.Namespace.TopLevelType.NestedType`n'.
            We do not know the boundary between namespace name and top level type, so we have to try
            all possibilities.
            The type parameter count only applies to the innermost type, all outer types must be non-generic.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IDocumentationProvider">
            <summary>
            Provides XML documentation for entities.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider">
            <summary>
            Provides XML documentation for entities.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IUnresolvedDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider">
            <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
            <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            The .xml file is only opened when necessary, the file handle is not kept open all the time.
            If the .xml file is changed, the index will automatically be recreated.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.HashCode">
            <summary>
            Hash code of the documentation tag
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.PositionInFile">
            <summary>
            Position in the .xml file where the documentation starts
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.Create(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider. Can return null if we couldn't read the file.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
            <returns>null if we couldn't create it</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.#ctor(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
            <exception cref="T:System.IO.IOException">Error reading from XML file (or from redirected file)</exception>
            <exception cref="T:System.Xml.XmlException">Invalid XML file</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LookupLocalizedXmlDoc(System.String)">
            <summary>
            Given the assembly file name, looks up the XML documentation file name.
            Returns null if no XML documentation file is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetHashCode(System.String)">
            <summary>
            Hash algorithm used for the index.
            This is a custom implementation so that old index files work correctly
            even when the .NET string.GetHashCode implementation changes
            (e.g. due to .NET 4.5 hash randomization)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
            <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.IdStringProvider">
            <summary>
            Provides ID strings for entities. (C# 4.0 spec, §A.3.1)
            ID strings are used to identify members in XML documentation files.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.GetIdString(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the ID string (C# 4.0 spec, §A.3.1) for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.ParseMemberIdString(System.String)">
            <summary>
            Parse the ID string into a member reference.
            </summary>
            <param name="memberIdString">The ID string representing the member (with "M:", "F:", "P:" or "E:" prefix).</param>
            <returns>A member reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            The member reference will look in <see cref="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly"/> first,
            and if the member is not found there,
            it will look in all other assemblies of the compilation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.ParseTypeName(System.String)">
            <summary>
            Parse the ID string type name into a type reference.
            </summary>
            <param name="typeName">The ID string representing the type (the "T:" prefix is optional).</param>
            <returns>A type reference that represents the ID string.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
            <remarks>
            <para>
            The type reference will look in <see cref="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly"/> first,
            and if the type is not found there,
            it will look in all other assemblies of the compilation.
            </para>
            <para>
            If the type is open (contains type parameters '`0' or '``0'),
            an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext"/> with the appropriate CurrentTypeDefinition/CurrentMember is required
            to resolve the reference to the ITypeParameter.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IdStringProvider.FindEntity(System.String,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Finds the entity in the given type resolve context.
            </summary>
            <param name="idString">ID string of the entity.</param>
            <param name="context">Type resolve context</param>
            <returns>Returns the entity, or null if it is not found.</returns>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the ID string is invalid</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.IAnnotatable">
            <summary>
            Provides an interface to handle annotations in an object.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.IAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this IAnnotatable.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation``1">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <typeparam name='T'>
            The type of the annotation.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation(System.Type)">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <param name='type'>
            The type of the annotation.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.AddAnnotation(System.Object)">
            <summary>
            Adds an annotation to this instance.
            </summary>
            <param name='annotation'>
            The annotation to add.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations``1">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <typeparam name='T'>
            The type of the annotations to remove.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations(System.Type)">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <param name='type'>
            The type of the annotations to remove.
            </param>
        </member>
        <member name="T:ICSharpCode.NRefactory.AbstractAnnotatable">
            <summary>
            Base class used to implement the IAnnotatable interface.
            This implementation is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.AbstractAnnotatable.CloneAnnotations">
            <summary>
            Clones all annotations.
            This method is intended to be called by Clone() implementations in derived classes.
            <code>
            AstNode copy = (AstNode)MemberwiseClone();
            copy.CloneAnnotations();
            </code>
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.AbstractAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this AstNode.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.BacktrackingInfo">
            <summary>
            Container for the backtracking info.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Choice">
            <summary>
            Matches one of several alternatives.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNode">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Backreference">
            <summary>
            Matches the last entry in the specified named group.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.INode">
            <summary>
            AST node that supports pattern matching.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.PatternMatching.PatternExtensions.Match(ICSharpCode.NRefactory.PatternMatching.INode,ICSharpCode.NRefactory.PatternMatching.INode)">
            <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other"/> is the AST that is being matched.
            </summary>
            <returns>
            A match object. Check <see cref="P:ICSharpCode.NRefactory.PatternMatching.Match.Success"/> to see whether the match was successful.
            </returns>
            <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Match">
            <summary>
            Represents the result of a pattern matching operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.NamedNode">
            <summary>
            Represents a named node within a pattern.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Repeat">
            <summary>
            Represents an optional node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Pattern">
            <summary>
            Base class for all patterns.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.PatternMatching.Pattern.AnyString">
            <summary>
            Gets the string that matches any string.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNodeOrNull">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role">
            <summary>
            Represents the role a node plays within its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.IsValid(System.Object)">
            <summary>
            Gets whether the specified node is valid in this role.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.GetByIndex(System.UInt32)">
            <summary>
            Gets the role with the specified index.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role`1">
            <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Role`1.NullObject">
            <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
            <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, if a role used for collections only, it may leave out the null object.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.AmbiguousTypeResolveResult">
            <summary>
            Represents an ambiguous type resolve result.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.AmbiguousMemberResolveResult">
            <summary>
            Represents an ambiguous field/property/event access.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayAccessResolveResult">
            <summary>
            Resolve result representing an array access.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult">
            <summary>
            Resolve result representing an array creation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.SizeArguments">
            <summary>
            Gets the size arguments.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.InitializerElements">
            <summary>
            Gets the initializer elements.
            This field may be null if no initializer was specified.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ByReferenceResolveResult">
            <summary>
            Represents the resolve result of an 'ref x' or 'out x' expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ConstantResolveResult">
            <summary>
            ResolveResult representing a compile-time constant.
            Note: this class is mainly used for literals; there may be other ResolveResult classes
            which are compile-time constants as well.
            For example, a reference to a <c>const</c> field results in a <see cref="T:ICSharpCode.NRefactory.Semantics.MemberResolveResult"/>.
            
            Check <see cref="P:ICSharpCode.NRefactory.Semantics.ResolveResult.IsCompileTimeConstant"/> to determine is a resolve result is a constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult">
            <summary>
            Represents an implicit or explicit type conversion.
            <c>conversionResolveResult.Input.Type</c> is the source type;
            <c>conversionResolveResult.Type</c> is the target type.
            The <see cref="F:ICSharpCode.NRefactory.Semantics.ConversionResolveResult.Conversion"/> property provides details about the kind of conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ConversionResolveResult.CheckForOverflow">
            <summary>
            For numeric conversions, specifies whether overflow checking is enabled.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.SizeOfResolveResult">
            <summary>
            Represents the 'sizeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.SizeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'sizeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ErrorResolveResult">
            <summary>
            Represents a resolve error.
            
            Note: some errors are represented by other classes; for example a <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult"/> may
            be erroneous if the conversion is invalid.
            </summary>
            <seealso cref="P:ICSharpCode.NRefactory.Semantics.ResolveResult.IsError"/>.
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ErrorResolveResult.UnknownError">
            <summary>
            Gets an ErrorResolveResult instance with <c>Type</c> = <c>SpecialType.UnknownType</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.Conversion">
            <summary>
            Holds information about a conversion between two types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.None">
            <summary>
            Not a valid conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.IdentityConversion">
            <summary>
            Identity conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.ImplicitConstantExpressionConversion">
            <summary>
            The numeric conversion of a constant expression.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.TryCast">
            <summary>
            C# 'as' cast.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsValid">
            <summary>
            Gets whether the conversion is valid.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsTryCast">
            <summary>
            Gets whether the conversion is an '<c>as</c>' cast.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsLifted">
            <summary>
            Gets whether this conversion is a lifted version of another conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsDynamicConversion">
            <summary>
            Gets whether the conversion is dynamic.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsReferenceConversion">
            <summary>
            Gets whether the conversion is a reference conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsEnumerationConversion">
            <summary>
            Gets whether the conversion is an enumeration conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsNullableConversion">
            <summary>
            Gets whether the conversion is a nullable conversion
            (conversion between a nullable type and the regular type).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUserDefined">
            <summary>
            Gets whether this conversion is user-defined (op_Implicit or op_Explicit).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.ConversionBeforeUserDefinedOperator">
            <summary>
            The conversion that is applied to the input before the user-defined conversion operator is invoked.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.ConversionAfterUserDefinedOperator">
            <summary>
            The conversion that is applied to the result of the user-defined conversion operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsBoxingConversion">
            <summary>
            Gets whether this conversion is a boxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUnboxingConversion">
            <summary>
            Gets whether this conversion is an unboxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsPointerConversion">
            <summary>
            Gets whether this conversion is a pointer conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsMethodGroupConversion">
            <summary>
            Gets whether this conversion is a method group conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsVirtualMethodLookup">
            <summary>
            For method-group conversions, gets whether to perform a virtual method lookup at runtime.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.DelegateCapturesFirstArgument">
            <summary>
            For method-group conversions, gets whether the conversion captures the first argument.
            
            For instance methods, this property always returns true for C# method-group conversions.
            For static methods, this property returns true for method-group conversions of an extension method performed on an instance (eg. <c>Func&lt;int&gt; f = myEnumerable.Single</c>).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsAnonymousFunctionConversion">
            <summary>
            Gets whether this conversion is an anonymous function conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.Method">
            <summary>
            Gets the method associated with this conversion.
            For user-defined conversions, this is the method being called.
            For method-group conversions, this is the method that was chosen from the group.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ForEachResolveResult">
            <summary>
            Resolve result representing a 'foreach' loop.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.GetEnumeratorCall">
            <summary>
            Gets the semantic tree for the call to GetEnumerator.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.CollectionType">
            <summary>
            Gets the collection type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.EnumeratorType">
            <summary>
            Gets the enumerator type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.ElementType">
            <summary>
            Gets the element type.
            This is the type that would be inferred for an implicitly-typed element variable.
            For explicitly-typed element variables, this type may differ from <c>ElementVariable.Type</c>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.ElementVariable">
            <summary>
            Gets the element variable.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.CurrentProperty">
            <summary>
            Gets the Current property on the IEnumerator.
            Returns null if the property is not found.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ForEachResolveResult.MoveNextMethod">
            <summary>
            Gets the MoveNext() method on the IEnumerator.
            Returns null if the method is not found.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult">
            <summary>
            Refers to the object that is currently being initialized.
            Used within <see cref="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult">
            <summary>
            Represents the result of a method, constructor or indexer invocation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.Arguments">
            <summary>
            Gets the arguments that are being passed to the method, in the order the arguments are being evaluated.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements">
            <summary>
            Gets the list of initializer statements that are appplied to the result of this invocation.
            This is used to represent object and collection initializers.
            With the initializer statements, the <see cref="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult"/> is used
            to refer to the result of this invocation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.GetArgumentsForCall">
            <summary>
            Gets the arguments in the order they are being passed to the method.
            For parameter arrays (params), this will return an ArrayCreateResolveResult.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.LocalResolveResult">
            <summary>
            Represents a local variable or parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.MemberResolveResult">
            <summary>
            Represents the result of a member invocation.
            Used for field/property/event access.
            Also, <see cref="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult"/> derives from MemberResolveResult.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.MemberResolveResult.Member">
            <summary>
            Gets the member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.MemberResolveResult.IsVirtualCall">
            <summary>
            Gets whether this MemberResolveResult is a virtual call.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult">
            <summary>
            Represents a named argument.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Member">
            <summary>
            Gets the member to which the parameter belongs.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Parameter">
            <summary>
            Gets the parameter.
            This field can be null.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.ParameterName">
            <summary>
            Gets the parameter name.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult.Argument">
            <summary>
            Gets the argument passed to the parameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.NamespaceResolveResult">
            <summary>
            Represents that an expression resolved to a namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.OperatorResolveResult">
            <summary>
            Represents a unary/binary/ternary operator invocation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.OperatorType">
            <summary>
            Gets the operator type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.Operands">
            <summary>
            Gets the operands.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.UserDefinedOperatorMethod">
            <summary>
            Gets the user defined operator method.
            Returns null if this is a predefined operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.IsLiftedOperator">
            <summary>
            Gets whether this is a lifted operator.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ResolveResult">
            <summary>
            Represents the result of resolving an expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ThisResolveResult">
            <summary>
            Represents the 'this' reference.
            Also used for the 'base' reference.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.ThisResolveResult.CausesNonVirtualInvocation">
            <summary>
            Gets whether this resolve result causes member invocations to be non-virtual.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeIsResolveResult">
            <summary>
            Resolve result for a C# 'is' expression.
            "Input is TargetType".
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.TypeIsResolveResult.TargetType">
            <summary>
            Type that is being compared with.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult">
            <summary>
            Represents the 'typeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'typeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeResolveResult">
            <summary>
            The resolved expression refers to a type name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult">
            <summary>
            Represents an unknown member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult.TargetType">
            <summary>
            The type on which the method is being called.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMethodResolveResult">
            <summary>
            Represents an unknown method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownIdentifierResolveResult">
            <summary>
            Represents an unknown identifier.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TextLocation">
            <summary>
            A line/column position.
            Text editor lines/columns are counted started from one.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.Empty">
            <summary>
            Represents no text location (0, 0).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinLine">
            <summary>
            Constant of the minimum line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinColumn">
            <summary>
            Constant of the minimum column.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextLocation instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Line">
            <summary>
            Gets the line number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Column">
            <summary>
            Gets the column number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.IsEmpty">
            <summary>
            Gets whether the TextLocation instance is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.ToString">
            <summary>
            Gets a string representation for debugging purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.GetHashCode">
            <summary>
            Gets a hash code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Equality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Inequality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Inequality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.CompareTo(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Accessibility">
            <summary>
            Enum that describes the accessibility of an entity.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.None">
            <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Private">
            <summary>
            The entity is only accessible within the same class.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Public">
            <summary>
            The entity is accessible everywhere.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Protected">
            <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Internal">
            <summary>
            The entity is accessible within the same project content.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedOrInternal">
            <summary>
            The entity is accessible both everywhere in the project content, and in all derived classes.
            </summary>
            <remarks>This corresponds to C# 'protected internal'.</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedAndInternal">
            <summary>
            The entity is accessible in derived classes within the same project content.
            </summary>
            <remarks>C# does not support this accessibility.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.Accessibility">
            <summary>
            Gets the accessibility of this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPrivate">
            <summary>
            Gets a value indicating whether this instance is private.
            </summary>
            <value>
            <c>true</c> if this instance is private; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPublic">
            <summary>
            Gets a value indicating whether this instance is public.
            </summary>
            <value>
            <c>true</c> if this instance is public; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtected">
            <summary>
            Gets a value indicating whether this instance is protected.
            </summary>
            <value>
            <c>true</c> if this instance is protected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsInternal">
            <summary>
            Gets a value indicating whether this instance is internal.
            </summary>
            <value>
            <c>true</c> if this instance is internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedOrInternal">
            <summary>
            Gets a value indicating whether this instance is protected or internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected or internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedAndInternal">
            <summary>
            Gets a value indicating whether this instance is protected and internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected and internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.AnonymousType">
            <summary>
            Anonymous type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.AnonymousTypeReference">
            <summary>
            Anonymous type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ArrayType">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ComHelper">
            <summary>
            Helper methods for COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ComHelper.IsComImport(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether the specified type is imported from COM.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ComHelper.GetCoClass(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets the CoClass of the specified COM interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot">
            <summary>
            Default implementation of ISolutionSnapshot.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IProjectContent})">
            <summary>
            Creates a new DefaultSolutionSnapshot with the specified projects.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DefaultSolutionSnapshot.#ctor">
            <summary>
            Creates a new DefaultSolutionSnapshot that does not support <see cref="T:ICSharpCode.NRefactory.TypeSystem.ProjectReference"/>s.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndLine">
            <value>
            if the end line is == -1 the end column is -1 too
            this stands for an unknwon end
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndColumn">
            <value>
            if the end column is == -1 the end line is -1 too
            this stands for an unknown end
            </value>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.IsInside(System.Int32,System.Int32)">
            <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.Contains(System.Int32,System.Int32)">
            <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.TypeDefinition">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Field">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IField"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Property">
            <summary>
            The symbol is a property, but not an indexer.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Indexer">
            <summary>
            The symbol is an indexer, not a regular property.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Event">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IEvent"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Method">
            <summary>
            The symbol is a method which is not an operator/constructor/destructor or accessor.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Operator">
            <summary>
            The symbol is a user-defined operator.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Constructor">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Destructor">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.EntityType.Accessor">
            <summary>
            The accessor method for a property getter/setter or event add/remove.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICodeContext.LocalVariables">
            <summary>
            Gets all currently visible local variables and lambda parameters.
            Does not include method parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICodeContext.IsWithinLambdaExpression">
            <summary>
            Gets whether the context is within a lambda expression or anonymous method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultVariable">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IVariable"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnresolvedAttributeBlob">
            <summary>
            <c>IUnresolvedAttribute</c> implementation that loads the arguments from a binary blob.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.FreezableHelper.GetFrozenClone``1(``0)">
            <summary>
            If the item is not frozen, this method creates and returns a frozen clone.
            If the item is already frozen, it is returned without creating a clone.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedEntity">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IEntity"/> that resolves an unresolved entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedMember">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMember"/> that resolves an unresolved member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractType">
            <summary>
            Default implementation for IType interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity"/> implementations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity.ApplyInterningProvider(ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
            <summary>
            Uses the specified interning provider to intern
            strings and lists in this entity.
            This method does not test arbitrary objects to see if they implement ISupportsInterning;
            instead we assume that those are interned immediately when they are created (before they are added to this entity).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity.Clone">
            <summary>
            Creates a shallow clone of this entity.
            Collections (e.g. a type's member list) will be cloned as well, but the elements
            of said list will not be.
            If this instance is frozen, the clone will be unfrozen.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedMember">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember"/> implementations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AccessorOwnerMemberReference">
            <summary>
            Given a reference to an accessor, returns the accessor's owner.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector">
            <summary>
            Helper class for the GetAllBaseTypes() implementation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector.SkipImplementedInterfaces">
            <summary>
            If this option is enabled, the list will not contain interfaces when retrieving the base types
            of a class.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAssemblyReference">
            <summary>
            References an existing assembly by name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAttribute">
            <summary>
            IAttribute implementation for already-resolved attributes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMemberReference">
            <summary>
            References an entity by its type and name.
            This class can be used to refer to all members except for constructors and explicit interface implementations.
            </summary>
            <remarks>
            Resolving a DefaultMemberReference requires a context that provides enough information for resolving the declaring type reference
            and the parameter types references.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IParameter"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/> that resolves an unresolved method.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod.GetDummyConstructor(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
            <summary>
            Gets a dummy constructor for the specified compilation.
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and no declaring type.
            </returns>
            <seealso cref="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod.GetDummyConstructor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets a dummy constructor for the specified type.
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and the specified declaring type.
            </returns>
            <seealso cref="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedTypeDefinition">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly">
            <summary>
            Default implementation for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.#ctor(System.String)">
            <summary>
            Creates a new unresolved assembly.
            </summary>
            <param name="assemblyName">Full assembly name</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AssemblyName">
            <summary>
            Gets/Sets the short assembly name.
            </summary>
            <remarks>
            This class handles the short and the full name independently;
            if you change the short name, you should also change the full name.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.FullAssemblyName">
            <summary>
            Gets/Sets the full assembly name.
            </summary>
            <remarks>
            This class handles the short and the full name independently;
            if you change the full name, you should also change the short name.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AddTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition)">
            <summary>
            Adds a new top-level type definition to this assembly.
            </summary>
            <remarks>DefaultUnresolvedAssembly does not support partial classes.
            Adding more than one part of a type will cause an ArgumentException.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AddTypeForwarder(ICSharpCode.NRefactory.TypeSystem.TopLevelTypeName,ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
            <summary>
            Adds a type forwarder.
            This adds both an assembly attribute and an internal forwarder entry, which will be used
            by the resolved assembly to provide the forwarded types.
            </summary>
            <param name="typeName">The name of the type.</param>
            <param name="referencedType">The reference used to look up the type in the target assembly.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAttribute">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedEvent">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedField">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod" /> interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod.DummyConstructor">
            <summary>
            Returns a dummy constructor instance:
            </summary>
            <returns>
            A public instance constructor with IsSynthetic=true and no declaring type.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedParameter">
            <summary>
            Default implementation for IUnresolvedParameter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedProperty">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeDefinition">
            <summary>
            Represents an unresolved type definition.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeParameter.ApplyInterningProvider(ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
            <summary>
            Uses the specified interning provider to intern
            strings and lists in this entity.
            This method does not test arbitrary objects to see if they implement ISupportsInterning;
            instead we assume that those are interned immediately when they are created (before they are added to this entity).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeMethodTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeClassTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of class type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DummyTypeParameter.NormalizeAllTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of class and method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.ExplicitInterfaceImplementationMemberReference">
            <summary>
            References a member that is an explicit interface implementation.
            </summary>
            <remarks>
            Resolving an ExplicitInterfaceImplementationMemberReference requires a context
            that provides enough information for resolving the declaring type reference
            and the interface member reference.
            Note that the interface member reference is resolved in '<c>context.WithCurrentTypeDefinition(declaringType.GetDefinition())</c>'
            - this is done to ensure that open generics in the interface member reference resolve to the type parameters of the
            declaring type.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference">
            <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.FullTypeName,ICSharpCode.NRefactory.TypeSystem.IAssemblyReference)">
            <summary>
            Creates a new GetClassTypeReference that searches a type definition.
            </summary>
            <param name="fullTypeName">The full name of the type.</param>
            <param name="assembly">A reference to the assembly containing this type.
            If this parameter is null, the GetClassTypeReference will search in all
            assemblies belonging to the compilation.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in all assemblies.
            </summary>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.IAssemblyReference,System.String,System.String,System.Int32)">
            <summary>
            Creates a new GetClassTypeReference that searches a top-level type in the specified assembly.
            </summary>
            <param name="assembly">A reference to the assembly containing this type.
            If this parameter is null, the GetClassTypeReference will search in all assemblies belonging to the ICompilation.</param>
            <param name="namespaceName">The namespace name containing the type, e.g. "System.Collections.Generic".</param>
            <param name="name">The name of the type, e.g. "List".</param>
            <param name="typeParameterCount">The number of type parameters, (e.g. 1 for List&lt;T&gt;).</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.Assembly">
            <summary>
            Gets the assembly reference.
            This property returns null if the GetClassTypeReference is searching in all assemblies
            of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.FullTypeName">
            <summary>
            Gets the full name of the type this reference is searching for.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetMembersHelper">
            <summary>
            Provides helper methods for implementing GetMembers() on IType-implementations.
            Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
            both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
            and only the 'simple' overloads (not taking type arguments).
            
            Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
            otherwise you'll get a StackOverflowException!
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.KnownTypeCache">
            <summary>
            Cache for KnownTypeReferences.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace">
            <summary>
            A merged namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.INamespace[],System.String)">
            <summary>
            Creates a new merged root namespace.
            </summary>
            <param name="compilation">The main compilation.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
            <param name="externAlias">The extern alias for this namespace.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.INamespace,ICSharpCode.NRefactory.TypeSystem.INamespace[])">
            <summary>
            Creates a new merged child namespace.
            </summary>
            <param name="parentNamespace">The parent merged namespace.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MinimalCorlib">
            <summary>
            Resolve context represents the minimal mscorlib required for evaluating constants.
            This contains all known types (<see cref="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode"/>) and no other types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference">
            <summary>
            Type reference used to reference nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,System.Int32)">
            <summary>
            Creates a new NestedTypeReference.
            </summary>
            <param name="declaringTypeRef">Reference to the declaring type.</param>
            <param name="name">Name of the nested class</param>
            <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
            <remarks>
            <paramref name="declaringTypeRef"/> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleCompilation">
            <summary>
            Simple compilation implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleConstantValue">
            <summary>
            A simple constant value that is independent of the resolve context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider">
            <summary>
            Simple interning provider.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent">
            <summary>
            Represents a specialized IEvent (event after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField">
            <summary>
            Represents a specialized IField (field after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember">
            <summary>
            Represents a SpecializedMember (a member on which type substitution has been performed).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember.AddSubstitution(ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution)">
            <summary>
            Performs a substitution. This method may only be called by constructors in derived classes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember.Substitution">
            <summary>
            Gets the substitution belonging to this specialized member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod">
            <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty">
            <summary>
            Represents a specialized IProperty (property after type substitution).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeParameterReference.Create(ICSharpCode.NRefactory.TypeSystem.SymbolKind,System.Int32)">
            <summary>
            Creates a type parameter reference.
            For common type parameter references, this method may return a shared instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType">
            <summary>
            An unknown type where (part) of the name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="namespaceName">Namespace name, if known. Can be null if unknown.</param>
            <param name="name">Name of the type, must not be null.</param>
            <param name="typeParameterCount">Type parameter count, zero if unknown.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType.#ctor(ICSharpCode.NRefactory.TypeSystem.FullTypeName)">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="fullTypeName">Full name of the unknown type.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.VoidTypeDefinition">
            <summary>
            Special type definition for 'void'.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.TypeDefinition">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Field">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IField"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Property">
            <summary>
            The symbol is a property, but not an indexer.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Indexer">
            <summary>
            The symbol is an indexer, not a regular property.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Event">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IEvent"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Method">
            <summary>
            The symbol is a method which is not an operator/constructor/destructor or accessor.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Operator">
            <summary>
            The symbol is a user-defined operator.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Constructor">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Destructor">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Accessor">
            <summary>
            The accessor method for a property getter/setter or event add/remove.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Namespace">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.INamespace"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Variable">
            <summary>
            The symbol is a variable, but not a parameter.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IVariable"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.Parameter">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.IParameter"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SymbolKind.TypeParameter">
            <seealso cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISymbol">
            <summary>
            Interface for type system symbols.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ISymbol.SymbolKind">
            <summary>
            This property returns an enum specifying which kind of symbol this is
            (which derived interfaces of ISymbol are implemented)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ISymbol.Name">
            <summary>
            Gets the short name of the symbol.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISymbol.ToReference">
            <summary>
            Creates a symbol reference that can be used to rediscover this symbol in another compilation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TaskType">
            <summary>
            Helper class for dealing with System.Threading.Tasks.Task.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TaskType.UnpackTask(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the T in Task&lt;T&gt;.
            Returns void for non-generic Task.
            Any other type is returned unmodified.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TaskType.IsTask(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is Task or Task&lt;T&gt;.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.TaskType.Create(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Creates a task type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution">
            <summary>
            Substitutes class and method type parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeParameterSubstitution.Identity">
    